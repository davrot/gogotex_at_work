name: Parity flakiness summary

on:
  schedule:
    - cron: "0 4 * * 1" # weekly on Monday 04:00 UTC
  workflow_dispatch: {}

permissions:
  actions: read
  contents: read
  issues: write

jobs:
  collect-flakiness:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Ensure tools
        run: |
          # Install required tools (unzip, jq, curl, python3)
          apt-get update && apt-get install -y unzip jq curl python3 || true
          # verify availability
          jq --version || true
          python3 --version || true
          curl --version >/dev/null 2>&1 || true

      - name: Validate inputs
        run: |
          if [ -z "${{ secrets.GITHUB_TOKEN }}" ]; then echo "GITHUB_TOKEN secret is not set; aborting" && exit 1; fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Collect flakiness artifacts
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_REPOSITORY: ${{ github.repository }}
        run: |
          ./scripts/contract/collect_flakiness.sh

      - name: Upload aggregate report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: parity-flakiness-aggregate
          path: ci/flakiness/

      - name: Upload cross-instance dashboard
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: parity-cross-dashboard
          path: ci/flakiness/cross/dashboard.html || true

      - name: Create issue if failures exist
        if: always()
        uses: actions/github-script@v6
        with:
          script: |
            const fs = require('fs')
            const core = require('@actions/core')
            const report = fs.existsSync('ci/flakiness/report.txt') ? fs.readFileSync('ci/flakiness/report.txt','utf8') : 'no report'
            const aggPath = 'ci/flakiness/aggregate.json'
            let agg = []
            if (fs.existsSync(aggPath)) agg = JSON.parse(fs.readFileSync(aggPath,'utf8'))
            const failures = agg.filter(x => x.success !== true).length
            // include cross-instance summary when present
            let crossSummary = ''
            const crossReportPath = 'ci/flakiness/cross/report.txt'
            if (fs.existsSync(crossReportPath)) {
              try { crossSummary = '\n\nCross-instance summary:\n' + fs.readFileSync(crossReportPath,'utf8') } catch (e) { crossSummary = '\n\nCross-instance summary: failed to read cross report' }
            }
            if (failures > 0) {
              const body = `Automated weekly parity flakiness report:\n\n${report}${crossSummary}\n\nAttached aggregate JSON and cross-instance dashboard (if present).`
              await github.rest.issues.create({ owner: github.context.repo.owner, repo: github.context.repo.repo, title: `Parity flakiness weekly summary (${new Date().toISOString().slice(0,10)})`, body })
              // Slack notify (optional): post cross-instance summary if SLACK_WEBHOOK configured
              const slackWebhook = process.env.SLACK_WEBHOOK
              if (slackWebhook) {
                let slackMsg = `Parity flakiness weekly summary: failures=${failures}`
                if (crossSummary) slackMsg += `\n\n${crossSummary}`
                try { await require('node-fetch')(slackWebhook, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ text: slackMsg }) }) } catch (e) { core.warning('Slack notify failed: ' + String(e)) }
              } else { core.info('SLACK_WEBHOOK not set; skipping weekly Slack notify') }
            } else {
              core.info('No failures detected this week; no issue created')
            }
